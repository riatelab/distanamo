[{"path":"https://riatelab.github.io/distanamo/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://riatelab.github.io/distanamo/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://riatelab.github.io/distanamo/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://riatelab.github.io/distanamo/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://riatelab.github.io/distanamo/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://riatelab.github.io/distanamo/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://riatelab.github.io/distanamo/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://riatelab.github.io/distanamo/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://riatelab.github.io/distanamo/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://riatelab.github.io/distanamo/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://riatelab.github.io/distanamo/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://riatelab.github.io/distanamo/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://riatelab.github.io/distanamo/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://riatelab.github.io/distanamo/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://riatelab.github.io/distanamo/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://riatelab.github.io/distanamo/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://riatelab.github.io/distanamo/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://riatelab.github.io/distanamo/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://riatelab.github.io/distanamo/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://riatelab.github.io/distanamo/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://riatelab.github.io/distanamo/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":"https://riatelab.github.io/distanamo/articles/distanamo.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Getting started with distanamo","text":"package allows create distance cartograms (distance anamorphoses, hence name). Distance cartograms type cartogram deforms layers map according distances set source points set image points. done extending (interpolation) layer(s) study area (territorial divisions, network…) local displacement source coordinates image coordinates, derived distances pair homologous points (source / image points). relation source points image points, thus relative position image points compared source points, must depend studied theme (positions access time package provides helper functions generate image points durations points).","code":""},{"path":"https://riatelab.github.io/distanamo/articles/distanamo.html","id":"more-information-about-the-origin-of-the-method","dir":"Articles","previous_headings":"Introduction","what":"More information about the origin of the method","title":"Getting started with distanamo","text":"port Darcy standalone software regarding bidimensional regression backgrounds layers deformation. credit contribution method goes Colette Cauvin (Théma - Univ. Franche-Comté) reference Java implementation goes Gilles Vuidel (Théma - Univ. Franche-Comté). method also available QGIS plugin (GitHub repository / QGIS plugin repository). R package wrapper around Rust library distance-cartogram-rs can used directly Rust. references method, see References end document.","code":""},{"path":"https://riatelab.github.io/distanamo/articles/distanamo.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Getting started with distanamo","text":"can install distanamo riatelab’s R-universe : Alternatively, can install development version distanamo GitHub : Note install GitHub, need Rust toolchain compile Rust code Minimum Supported Rust Version (MSRV) 1.82.0.","code":"install.packages('distanamo', repos = c('https://riatelab.r-universe.dev', 'https://cloud.r-project.org')) # install.packages(\"remotes\") remotes::install_github(\"riatelab/distanamo\")"},{"path":[]},{"path":"https://riatelab.github.io/distanamo/articles/distanamo.html","id":"basics","dir":"Articles","previous_headings":"Usage","what":"Basics","title":"Getting started with distanamo","text":"use package need provide two sets homologous points : source points image points. used create interpolation grid used deform layer(s) interest.","code":"# Read source points, image points and the background layer to deform source_pts <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = 'prefecture', quiet = TRUE ) image_pts <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = 'image-points', quiet = TRUE ) background_layer <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = 'departement', quiet = TRUE )  bbox <- sf::st_bbox(background_layer)  # Create the interpolation grid igrid <- dc_create(source_pts, image_pts, 2.0, bbox)  # Use it to deform our layer of interest deformed_background <- dc_interpolate(igrid, background_layer)  # Display useful information summary(igrid)  # Plot information about the interpolation grid plot(igrid)"},{"path":"https://riatelab.github.io/distanamo/articles/distanamo.html","id":"adjusting-the-image-points-to-the-source-points","dir":"Articles","previous_headings":"Usage","what":"Adjusting the image points to the source points","title":"Getting started with distanamo","text":"cases, may want adjust image points source points using affine Euclidean transformation. example, , image points represent locations spatial cognition (thus directly comparable source points, aren’t coordinate system, etc.), need adjust source points. also done internally using dc_generate_positions_from_durations function (see ) performed Principal Coordinates Analysis (PCoA) duration matrix.","code":"pos_result <- dc_adjust(     source_points = source_pts,     image_points = image_pts,     method = \"euclidean\" )  # Create the interpolation grid igrid <- dc_create(   pos_result$source_points,   pos_result$image_points,   2.0 )"},{"path":"https://riatelab.github.io/distanamo/articles/distanamo.html","id":"generating-image-points-from-a-reference-point-and-durations-from-the-reference-point-to-all-the-other-points","dir":"Articles","previous_headings":"Usage","what":"Generating image points from a reference point and durations from the reference point to all the other points","title":"Getting started with distanamo","text":"Optionally can provide layer source points matrix duration points. duration matrix used extract duration reference point points, allowing use dc_move_from_reference_point function move closer / farther points reference point depending can reached faster slower mean speed (reference point others). cartogram obtained method qualifies unipolar accessibility location (reference point used dc_move_from_reference_point function). ’s also sometimes referred centered time cartogram. popular way representing type cartogram add concentric circles (separated constant time) around reference point. can done using dc_concentric_circles function result dc_move_from_reference_point function (note steps parameter time, unit durations, circle).","code":"# Read source points and layer to be deformed source_pts <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = 'prefecture', quiet = TRUE ) background_layer <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = 'departement', quiet = TRUE ) bbox <- sf::st_bbox(background_layer)  # Read durations between points d <- read.csv(system.file(\"csv/mat.csv\", package = \"distanamo\"), row.names = 1)  # The CSV is a time matrix structured as follow #           AGEN   BORDEAUX   GRENOBLE etc. # AGEN      0.0    111.2      200.3 # BORDEAUX  112.3  0.0        300.1 # GRENOBLE  199.4  301.1      0.0 # etc. dv <- d['GRENOBLE', ] # So we have only the duration between GRENOBLE and all the other points #          AGEN   BORDEAUX   GRENOBLE etc. # GRENOBLE 199.4  301.1      0.0  source_pts$durations <- as.double(dv)  ref_point <- subset(source_pts, source_pts$NOM_COM == \"GRENOBLE\") other_points <- subset(source_pts, !source_pts$NOM_COM == \"GRENOBLE\")  # Move points to create the image points layer positioning_result <- dc_move_from_reference_point(   reference_point = ref_point,   other_points = other_points,   duration_col_name = \"durations\",   factor = 1 )  # Create the interpolation grid igrid <- dc_create(   positioning_result$source_points,   positioning_result$image_points,   2.0,   bbox )  # Deform the target layer deformed_background <- dc_interpolate(igrid, background_layer)  plot(sf::st_geometry(deformed_background)) circles <- dc_concentric_circles(   pos_result,   steps = list(10, 20, 30, 40, 50, 60) )"},{"path":"https://riatelab.github.io/distanamo/articles/distanamo.html","id":"generating-image-points-from-a-durations-matrix-between-all-the-points","dir":"Articles","previous_headings":"Usage","what":"Generating image points from a durations matrix between all the points","title":"Getting started with distanamo","text":"Optionally can provide matrix durations points well positions source points use dc_generate_positions_from_durations function generate image points. function perform Principal Coordinates Analysis (PCoA, form Multidimensional scaling) duration matrix generate positions points 2D space. adjust points (using affine Euclidean transformation) source points generate final image points can used create interpolation grid. cartogram obtained method qualifies global accessibility (multipolar accessibility) territory.","code":"# Read source points and layer to be deformed source_pts <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = 'prefecture', quiet = TRUE ) background_layer <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = 'departement', quiet = TRUE )  # Read durations between points d <- read.csv(system.file(\"csv/mat.csv\", package = \"distanamo\"), row.names = 1) # The CSV is a time matrix structured as follow #           AGEN   BORDEAUX   GRENOBLE etc. # AGEN      0.0    111.2      200.3 # BORDEAUX  112.3  0.0        300.1 # GRENOBLE  199.4  301.1      0.0 # etc.  pos_result <- dc_generate_positions_from_durations(d, source_pts)  # Display useful information about the result of the positioning summary(pos_result) plot(pos_result)  # Create the interpolation grid igrid <- dc_create(   pos_result$source_points,   pos_result$image_points,   2.0,   sf::st_bbox(background_layer) )  summary(igrid) plot(igrid)  # Deform the target layer deformed_background <- dc_interpolate(igrid, background_layer)  plot(sf::st_geometry(deformed_background))"},{"path":"https://riatelab.github.io/distanamo/articles/distanamo.html","id":"deforming-multiple-layers-at-once","dir":"Articles","previous_headings":"Usage","what":"Deforming multiple layers at once","title":"Getting started with distanamo","text":"want deform multiple layers parallel interpolation grid, can use dc_interpolate_parallel function.","code":"result_layers <- dc_interpolate_parallel(   igrid,   list(layer1, layer2, layer3) )"},{"path":[]},{"path":"https://riatelab.github.io/distanamo/articles/distanamo.html","id":"about-the-method","dir":"Articles","previous_headings":"References","what":"About the method","title":"Getting started with distanamo","text":"Cauvin, C. (2005). systemic approach transport accessibility. methodology developed Strasbourg: 1982-2002. Cybergeo: European Journal Geography. DOI: 10.4000/cybergeo.3425. Cauvin, C., & Vuidel, G. (2009). Darcy 2.0 - Mode d’emploi (https://thema.univ-fcomte.fr/productions/software/darcy/download/me_darcy.pdf). Tobler, W. R. (1994). Bidimensional regression. Geographical Analysis, 26(3), 187-212. DOI: 10.1111/j.1538-4632.1994.tb00320.x Bronner, . C. (2023). Cartogrammes, anamorphoses : des territoires transformés. Traitements et cartographie de l’information géographique, ISTE Group (pp.231-271). DOI: 10.51926/ISTE.9161.ch7.","code":""},{"path":"https://riatelab.github.io/distanamo/articles/distanamo.html","id":"about-distance-or-time-cartograms-in-general-their-usability-the-other-methods-to-create-them-etc-","dir":"Articles","previous_headings":"References","what":"About distance (or time) cartograms in general: their usability, the other methods to create them, etc.","title":"Getting started with distanamo","text":"Ullah, R., Mengistu, E., van Elzakker, C. & Kraak, M. (2016). Usability evaluation centered time cartograms. Open Geosciences, 8(1), 337-359. DOI: 10.1515/geo-2016-0035. Hong, S., Kim, Y. S., Yoon, J. C., & Aragon, C. (2014). Traffigram: distortion clarification via isochronal cartography. Proceedings SIGCHI Conference Human Factors Computing Systems (pp. 907–916). Association Computing Machinery. DOI: 10.1145/2556288.2557224. Ullah, R., Kraak, M. J., & Van Elzakker, C. (2013). Using cartograms explore temporal data: work. GeoViz, 2013. Ullah, R., & Kraak, M. J. (2014). alternative method constructing time cartograms visual representation scheduled movement data. Journal Maps, 11(4), 674–687. DOI: 10.1080/17445647.2014.935502. Hong, S., Kocielnik, R., Min-Joon Yoo, Battersby, S., Juho Kim, & Aragon, C. (2017). Designing interactive distance cartograms support urban travelers. 2017 IEEE Pacific Visualization Symposium (PacificVis) (pp. 81-90). Shimizu, E. Inoue, R. (2009). new algorithm distance cartogram construction. International Journal Geographical Information Science 23(11): 1453-1470. DOI: 10.1080/13658810802186882.","code":""},{"path":"https://riatelab.github.io/distanamo/articles/web_only/reproducing-ancient-map.html","id":"introduction","dir":"Articles > Web_only","previous_headings":"","what":"Introduction","title":"Reproducing an ancient accessibility map as a time cartogram","text":"Representing accessibility cartography challenging task. One way use isochrone maps, visual representations areas can reach within given time one (sometimes several) starting point(s).  type map, common show areas can reached several given time steps, coloring different zones gradient tints (thus creating known cartography choropleth map).  vignette, use travel times displayed ancient isochrone map 19th century order create time cartogram.","code":""},{"path":"https://riatelab.github.io/distanamo/articles/web_only/reproducing-ancient-map.html","id":"reference-map","dir":"Articles > Web_only","previous_headings":"","what":"Reference map","title":"Reproducing an ancient accessibility map as a time cartogram","text":"reference map use isochrone map France showing travel times train Paris 1882. named “Carte des communications rapides entre Paris et le reste de la France” (Map fast communications Paris rest France) drawn French cartographer E. Martin. can viewed high resolution Library Chicago University.  zoom map, can see travel times displayed next city name. indicated bottom map (French), time indicated hours minutes corresponds average fastest train journey time Paris fastest train journey time town question Paris.  example, travel time Saint-Brieuc reads 10h30 store 630 minutes dataset creating.","code":""},{"path":"https://riatelab.github.io/distanamo/articles/web_only/reproducing-ancient-map.html","id":"data-extraction","dir":"Articles > Web_only","previous_headings":"","what":"Data extraction","title":"Reproducing an ancient accessibility map as a time cartogram","text":"first step extract travel times map. Due nature document, ’ll extract manually (OCR extraction tested didn’t give satisfactory results). addition, map includes many cities, ’re going concentrate main ones make exercise easier. therefore enter data CSV file, using following format (first line list cities, first column list cities, cells contain travel times minutes):","code":"csv_data <- \",PARIS,LILLE,DIEPPE,CHERBOURG-EN-COTENTIN,ROUEN,SAINT-BRIEUC,REIMS,NANCY,BREST,RENNES,LE MANS,CHAUMONT,EPINAL,TOURS,QUIMPER,VANNES,DIJON,BESANCON,LA ROCHE-SUR-YON,LA ROCHELLE,CLERMONT-FERRAND,LYON,ALBERTVILLE,GRENOBLE,RODEZ,BORDEAUX,TOULOUSE,HENDAYE,FOIX,PERPIGNAN,MARSEILLE,NICE PARIS,0,250,240,535,160,630,180,395,825,450,240,255,575,350,970,765,345,510,490,530,525,530,895,815,880,545,850,1015,1170,1100,935,1410\"  data <- read.csv(text = csv_data)"},{"path":[]},{"path":"https://riatelab.github.io/distanamo/articles/web_only/with-osm-data.html","id":"introduction","dir":"Articles > Web_only","previous_headings":"","what":"Introduction","title":"Creating a distance cartogram using OSM data","text":"looking build unipolar distance cartogram (also called centered time cartogram) using data OpenStreetMap (OSM): going use geographic layers describing territory travel time data OSM. type cartogram visualizes travelling times reference starting location destinations selected area. resulting map, geographic distance replaced time distance underlying map layers deformed accordingly. highlights use several packages developed RIATE, including: mapsf create maps sf objects, osrm calculating distance-time matrices OSM data OSRM instance, valh calculating distance-time matrices OSM data Valhalla instance, maposm easily retrieve OSM data (wrapper around osmdata), distanamo creating distance cartograms.","code":""},{"path":"https://riatelab.github.io/distanamo/articles/web_only/with-osm-data.html","id":"installing-and-importing-packages","dir":"Articles > Web_only","previous_headings":"","what":"Installing and importing packages","title":"Creating a distance cartogram using OSM data","text":"mapsf osrm available CRAN riatelab’s r-universe distanamo maposm available riatelab’s r-universe. result, propose install packages r-universe: installed, can import necessary packages:","code":"repos <- c(\"https://riatelab.r-universe.dev\", \"https://cloud.r-project.org\")  install.packages(\"mapsf\", repos = repos) install.packages(\"osrm\", repos = repos) install.packages(\"distanamo\", repos = repos) install.packages(\"maposm\", repos = repos) library(sf) library(mapsf) library(osrm) library(maposm) library(distanamo)"},{"path":"https://riatelab.github.io/distanamo/articles/web_only/with-osm-data.html","id":"fetching-osm-data","dir":"Articles > Web_only","previous_headings":"","what":"Fetching OSM data","title":"Creating a distance cartogram using OSM data","text":"now retrieving OSM data study area choice: interested accessibility (foot, see later) market hall Chambéry. Let’s get coordinates address Chambéry’s market hall fetch data radius 3000 meters around : can see resulting object list sf layers:","code":"bb <- osmdata::getbb(\"10, Place Georges Clemenceau, 73100 Chambéry, France\") lon <- mean(bb[1, ]) lat <- mean(bb[2, ]) res <- om_get(c(lon, lat), r = 3000) #> Getting urban areas: 29.186 sec elapsed #> Getting green areas: 20.762 sec elapsed #> Getting roads: 18.48 sec elapsed #> Getting streets: 20.314 sec elapsed #> Getting railways: 0.681 sec elapsed #> Getting water bodies: 4.091 sec elapsed names(res) #> [1] \"zone\"     \"urban\"    \"building\" \"green\"    \"road\"     \"street\"   \"railway\"  #> [8] \"water\""},{"path":"https://riatelab.github.io/distanamo/articles/web_only/with-osm-data.html","id":"defining-a-reference-point","dir":"Articles > Web_only","previous_headings":"","what":"Defining a reference point","title":"Creating a distance cartogram using OSM data","text":"need define reference point travel times computed. Since used address Chambéry’s market hall center point fetch data, can use center circle includes data:","code":"start <- st_centroid(res$zone)"},{"path":"https://riatelab.github.io/distanamo/articles/web_only/with-osm-data.html","id":"sampling-points","dir":"Articles > Web_only","previous_headings":"","what":"Sampling points","title":"Creating a distance cartogram using OSM data","text":"need set destinations compute travel times . , sample roughly 200 points road network. Note use road street network layers , cases (particularly using car profile) may appropriate use road network.","code":"x <- st_sample(rbind(res$road, res$street), size = 200, type = \"regular\") # Or if you want to use only the road network: # x <- st_sample(res$road, size = 200, type = \"regular\") points <- st_sf(id = seq_along(x), geom = x) plot(st_geometry(points))"},{"path":"https://riatelab.github.io/distanamo/articles/web_only/with-osm-data.html","id":"making-a-map-of-the-result","dir":"Articles > Web_only","previous_headings":"","what":"Making a map of the result","title":"Creating a distance cartogram using OSM data","text":"","code":"mf_map(res$zone, col = \"#f2efe9\", border = NA, add = FALSE) mf_map(res$green, col = \"#c8facc\", border = \"#c8facc\", lwd = .5, add = TRUE) mf_map(res$water, col = \"#aad3df\", border = \"#aad3df\", lwd = .5, add = TRUE) mf_map(res$railway, col = \"grey50\", lty = 2, lwd = .2, add = TRUE) mf_map(res$road, col = \"white\", border = \"white\", lwd = .5, add = TRUE) mf_map(res$street, col = \"white\", border = \"white\", lwd = .5, add = TRUE) mf_map(res$building, col = \"#d9d0c9\", border = \"#c6bab1\", lwd = .5, add = TRUE) mf_map(res$zone, col = NA, border = \"#c6bab1\", lwd = 4, add = TRUE) mf_map(start, pch = 23, col = \"red\", cex = 2, add = T) mf_map(points, add = T, col = \"blue\")"},{"path":"https://riatelab.github.io/distanamo/articles/web_only/with-osm-data.html","id":"computing-travel-times-between-the-reference-point-and-the-sampled-points","dir":"Articles > Web_only","previous_headings":"","what":"Computing travel times between the reference point and the sampled points","title":"Creating a distance cartogram using OSM data","text":", can use osrmTable function osrm package:","code":"mat <- osrmTable(   src = start,   dst = points,   osrm.profile = \"foot\" )  points$durations <- t(mat$durations)"},{"path":"https://riatelab.github.io/distanamo/articles/web_only/with-osm-data.html","id":"alternative-to-osrm-for-computing-travel-times","dir":"Articles > Web_only","previous_headings":"Computing travel times between the reference point and the sampled points","what":"Alternative to OSRM for computing travel times","title":"Creating a distance cartogram using OSM data","text":"Alternatively, Valhalla instance hand data preparation step included elevation data, can also use compute travel times benefit taking elevation account: Note use environment variable store url Valhalla instance private instance. need replace Sys.getenv('VALHALLA_URL') actual value want use.","code":"install.packages(\"valh\", repos = repos) library(valh)  mat_val <- vl_matrix(   src = start,   dst = points,   costing = \"pedestrian\",   server = Sys.getenv(\"VALHALLA_URL\") )  points$durations <- t(mat_val$durations)"},{"path":"https://riatelab.github.io/distanamo/articles/web_only/with-osm-data.html","id":"computing-the-positions-of-image-points","dir":"Articles > Web_only","previous_headings":"","what":"Computing the positions of image points","title":"Creating a distance cartogram using OSM data","text":"can now compute positions image points using dc_move_from_reference_point function. takes input reference point, points, column name travel times other_points object. function move points computing reference speed (average distance / time) moving points closer reference point depending travel time reach . can call summary function obtain summary resulting object: can also plot resulting object visualize positions image points moved:","code":"pos_result <- dc_move_from_reference_point(   reference_point = start,   other_points = points,   duration_col_name = \"durations\" ) summary(pos_result) #> Summary of the unipolar displacement result: #> Min displacement: 3.692405 [m]  #> Mean displacement: 359.9702 [m]  #> Max displacement: 1276.343 [m] plot(pos_result)"},{"path":"https://riatelab.github.io/distanamo/articles/web_only/with-osm-data.html","id":"creating-the-concentric-circles","dir":"Articles > Web_only","previous_headings":"","what":"Creating the concentric circles","title":"Creating a distance cartogram using OSM data","text":"Since cartogram replace geographic distance time distance can create concentric circles represent time distance reference point. Internally, possible reference speed stored resulting object dc_move_from_reference_point function. steps parameter list time distances want represent cartogram, unit travel times (, minutes).","code":"circles <- dc_concentric_circles(   pos_result,   steps = list(10, 20, 30, 40) ) circles #> Simple feature collection with 4 features and 1 field #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 654600.8 ymin: 5728074 xmax: 661118.7 ymax: 5734592 #> Projected CRS: WGS 84 / Pseudo-Mercator #>   step                       geometry #> 1   10 LINESTRING (658674.5 573133... #> 2   20 LINESTRING (659489.3 573133... #> 3   30 LINESTRING (660304 5731333,... #> 4   40 LINESTRING (661118.7 573133..."},{"path":"https://riatelab.github.io/distanamo/articles/web_only/with-osm-data.html","id":"creating-the-distance-cartogram","dir":"Articles > Web_only","previous_headings":"","what":"Creating the distance cartogram","title":"Creating a distance cartogram using OSM data","text":"first need compute bounding box layers want deform using interpolation grid ensure interpolation grid covers whole area interest. can create interpolation grid: precision parameters controls size grid cells (higher precise, example 0.5 generally gives coarse result, 2 satisfactory result 4 particularly fine result). precision 2 usually good default value choose use . Various information can obtained interpolation grid: can also plot interpolation grid visualize source grid, interpolated grid, distance image points interpolated points, strength deformation.","code":"bbox <- dc_combine_bbox(res) igrid <- dc_create(   source_points = pos_result$source_points,   image_points = pos_result$image_points,   precision = 2,   bbox = bbox ) summary(igrid) #> Summary of the interpolation grid: #> Number of cells: 900  #> Precision: 211.693 (α = 2)  #> Deformation strength: 1.177372  #> Mean absolute error: 50.96566  #> RMSE (interp - image): 66.48959  #> RMSE x (interp - image): 48.76218  #> RMSE y (interp - image): 45.20084  #> RMSE (interp - source): 426.2467  #> RMSE x (interp - source): 313.5549  #> RMSE y (interp - source): 288.7378  #> R squared: 0.9989954 plot(igrid)"},{"path":"https://riatelab.github.io/distanamo/articles/web_only/with-osm-data.html","id":"deforming-the-background-layers","dir":"Articles > Web_only","previous_headings":"","what":"Deforming the background layers","title":"Creating a distance cartogram using OSM data","text":"Since multiple layers deform, can use dc_interpolate_parallel function deform layers :","code":"deformed <- dc_interpolate_parallel(igrid, res)"},{"path":"https://riatelab.github.io/distanamo/articles/web_only/with-osm-data.html","id":"mapping-the-result","dir":"Articles > Web_only","previous_headings":"","what":"Mapping the result","title":"Creating a distance cartogram using OSM data","text":"needed, can add various points (sample ) corresponding travel times see deformation correctly applied:","code":"mf_map(deformed$zone, col = \"#f2efe9\", border = NA, add = FALSE) mf_map(deformed$green, col = \"#c8facc\", border = \"#c8facc\", lwd = .5, add = TRUE) mf_map(deformed$water, col = \"#aad3df\", border = \"#aad3df\", lwd = .5, add = TRUE) mf_map(deformed$railway, col = \"grey50\", lty = 2, lwd = .2, add = TRUE) mf_map(deformed$road, col = \"white\", border = \"white\", lwd = .5, add = TRUE) mf_map(deformed$street, col = \"white\", border = \"white\", lwd = .5, add = TRUE) mf_map(deformed$building, col = \"#d9d0c9\", border = \"#c6bab1\", lwd = .5, add = TRUE) mf_map(deformed$zone, col = NA, border = \"#c6bab1\", lwd = 4, add = TRUE) mf_map(igrid$interpolated_grid, col = NA, border = \"#940000\", lwd = .1, add = TRUE) mf_map(start, pch = 16, col = \"red\", cex = 2, add = TRUE) mf_map(sf::st_intersection(circles, sf::st_union(sf::st_buffer(igrid$interpolated_grid, 0))),        col = \"red\", lty = 2, lwd = 2, add = TRUE)  for (i in 1:4) {   mapsf:::shadowtext(     sf::st_bbox(circles$geometry[i])$xmax,     start$geometry[[1]][2],     paste(i * 10, \"min\"),     col = \"purple\",     bg = \"white\",     r = 0.15   ) } mvd_pts <- igrid$interpolated_points mvd_pts$durations <- round(c(0, points$durations), 1)  mf_map(deformed$zone, col = \"#f2efe9\", border = NA, add = FALSE) mf_map(deformed$green, col = \"#c8facc\", border = \"#c8facc\", lwd = .5, add = TRUE) mf_map(deformed$water, col = \"#aad3df\", border = \"#aad3df\", lwd = .5, add = TRUE) mf_map(deformed$railway, col = \"grey50\", lty = 2, lwd = .2, add = TRUE) mf_map(deformed$road, col = \"white\", border = \"white\", lwd = .5, add = TRUE) mf_map(deformed$street, col = \"white\", border = \"white\", lwd = .5, add = TRUE) mf_map(deformed$building, col = \"#d9d0c9\", border = \"#c6bab1\", lwd = .5, add = TRUE) mf_map(deformed$zone, col = NA, border = \"#c6bab1\", lwd = 4, add = TRUE) mf_map(igrid$interpolated_grid, col = NA, border = \"#940000\", lwd = .1, add = TRUE) mf_map(start, pch = 16, col = \"red\", cex = 2, add = TRUE) mf_map(sf::st_intersection(circles, sf::st_union(sf::st_buffer(igrid$interpolated_grid, 0))),         col = \"red\", lty = 2, lwd = 2, add = TRUE)  for (i in 1:4) {   mapsf:::shadowtext(     sf::st_bbox(circles$geometry[i])$xmax,     start$geometry[[1]][2],     paste(i * 10, \"min\"),     col = \"purple\",     bg = \"white\",     r = 0.15   ) }  mf_map(mvd_pts, add = TRUE, col = \"blue\") mf_label(mvd_pts, var = \"durations\", col = \"black\", halo = TRUE, overlap = TRUE)"},{"path":"https://riatelab.github.io/distanamo/articles/web_only/with-osm-data.html","id":"conclusion","dir":"Articles > Web_only","previous_headings":"","what":"Conclusion","title":"Creating a distance cartogram using OSM data","text":"Distance cartograms way analyzing accessibility territory way depicting . case unipolar cartograms, proposed , reading generally fairly straightforward, making easy highlight portions territory difficult (least difficult average) reach example. addition concentric circles regular time steps makes possible quickly assess time distance portion territory reference point.","code":""},{"path":"https://riatelab.github.io/distanamo/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Matthieu Viry. Maintainer, author. Timothée Giraud. Contributor.","code":""},{"path":"https://riatelab.github.io/distanamo/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Viry M (2025). distanamo: Create Distance Cartograms. R package version 0.2.0, https://github.com/riatelab/distanamo, https://riatelab.github.io/distanamo/.","code":"@Manual{,   title = {distanamo: Create Distance Cartograms},   author = {Matthieu Viry},   year = {2025},   note = {R package version 0.2.0, https://github.com/riatelab/distanamo},   url = {https://riatelab.github.io/distanamo/}, }"},{"path":"https://riatelab.github.io/distanamo/index.html","id":"distanamo-","dir":"","previous_headings":"","what":"Distanamo: distance cartograms","title":"Distanamo: distance cartograms","text":"package allows create distance cartograms (distance anamorphoses, hence name). Distance cartograms type cartogram deforms layers map according distances set source points set image points. done extending (interpolation) layer(s) study area (territorial divisions, network…) local displacement source coordinates image coordinates, derived distances pair homologous points (source / image points). relation source points image points, thus relative position image points compared source points, must depend studied theme (positions access time package provides helper functions generate image points durations points). Note package geared towards creation cartograms based bidimensional regression technique specifically towards study comparison two 2D configurations order assess similarity. recommend using BiDimRegression package geared towards applying bidimensional regression area psychological research, face research comparison 2D-data patterns general. functionalities close proposed package (particular concerning multidimensional scaling rotation/scaling/translating/reflection one set points fit another) can also found Vegan package example.","code":""},{"path":"https://riatelab.github.io/distanamo/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Distanamo: distance cartograms","text":"can install distanamo riatelab’s R-universe : Alternatively, can install development version distanamo GitHub : Note install GitHub, need Rust toolchain compile Rust code Minimum Supported Rust Version (MSRV) 1.82.0.","code":"install.packages('distanamo', repos = \"https://riatelab.r-universe.dev\") # install.packages(\"remotes\") remotes::install_github(\"riatelab/distanamo\")"},{"path":[]},{"path":"https://riatelab.github.io/distanamo/index.html","id":"basics","dir":"","previous_headings":"Usage","what":"Basics","title":"Distanamo: distance cartograms","text":"use package need provide two sets homologous points : source points image points. used create interpolation grid used deform layer(s) interest.","code":"# Read source points, image points and the background layer to deform source_pts <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = 'prefecture', quiet = TRUE ) image_pts <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = 'image-points', quiet = TRUE ) background_layer <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = 'departement', quiet = TRUE )  bbox <- sf::st_bbox(background_layer)  # Create the interpolation grid igrid <- dc_create(source_pts, image_pts, 2.0, bbox)  # Use it to deform our layer of interest deformed_background <- dc_interpolate(igrid, background_layer)  # Display useful information summary(igrid)  # Plot information about the interpolation grid plot(igrid)"},{"path":"https://riatelab.github.io/distanamo/index.html","id":"adjusting-the-image-points-to-the-source-points","dir":"","previous_headings":"Usage","what":"Adjusting the image points to the source points","title":"Distanamo: distance cartograms","text":"cases, may want adjust image points source points using affine Euclidean transformation. example, , image points represent locations spatial cognition (thus directly comparable source points, aren’t coordinate system, etc.), need adjust source points. also done internally using dc_generate_positions_from_durations function (see ) performed Principal Coordinates Analysis (PCoA) duration matrix.","code":"pos_result <- dc_adjust(     source_points = source_pts,     image_points = image_pts,     method = \"euclidean\" )  # Create the interpolation grid igrid <- dc_create(   pos_result$source_points,   pos_result$image_points,   2.0 )"},{"path":"https://riatelab.github.io/distanamo/index.html","id":"generating-image-points-from-a-reference-point-and-travel-times-from-the-reference-point-to-all-the-other-points","dir":"","previous_headings":"Usage","what":"Generating image points from a reference point and travel times from the reference point to all the other points","title":"Distanamo: distance cartograms","text":"Optionally can provide layer source points matrix durations points. durations matrix used extract duration reference point points, allowing use dc_move_from_reference_point function move closer / farther points reference point depending can reached faster slower average speed (reference point others). cartogram obtained method qualifies unipolar accessibility location (reference point used dc_move_from_reference_point function). ’s also sometimes referred centered time cartogram. popular way representing type cartogram add concentric circles (separated constant time) around reference point. can done using dc_concentric_circles function result dc_move_from_reference_point function (note steps parameter travel time, unit durations matrix, circle).","code":"# Read source points and layer to be deformed source_pts <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = 'prefecture', quiet = TRUE ) background_layer <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = 'departement', quiet = TRUE ) bbox <- sf::st_bbox(background_layer)  # Read durations between points d <- read.csv(system.file(\"csv/mat.csv\", package = \"distanamo\"), row.names = 1)  # The CSV is a time matrix structured as follow #           AGEN   BORDEAUX   GRENOBLE etc. # AGEN      0.0    111.2      200.3 # BORDEAUX  112.3  0.0        300.1 # GRENOBLE  199.4  301.1      0.0 # etc. dv <- d['GRENOBLE', ] # So we have only the duration between GRENOBLE and all the other points #          AGEN   BORDEAUX   GRENOBLE etc. # GRENOBLE 199.4  301.1      0.0  source_pts$durations <- as.double(dv)  ref_point <- subset(source_pts, source_pts$NOM_COM == \"GRENOBLE\") other_points <- subset(source_pts, !source_pts$NOM_COM == \"GRENOBLE\")  # Move points to create the image points layer positioning_result <- dc_move_from_reference_point(   reference_point = ref_point,   other_points = other_points,   duration_col_name = \"durations\",   factor = 1 )  # Create the interpolation grid igrid <- dc_create(   positioning_result$source_points,   positioning_result$image_points,   2.0,   bbox )  # Deform the target layer deformed_background <- dc_interpolate(igrid, background_layer)  plot(sf::st_geometry(deformed_background)) circles <- dc_concentric_circles(   pos_result,   steps = list(10, 20, 30, 40, 50, 60) )"},{"path":"https://riatelab.github.io/distanamo/index.html","id":"generating-image-points-from-a-durations-matrix-between-all-the-points","dir":"","previous_headings":"Usage","what":"Generating image points from a durations matrix between all the points","title":"Distanamo: distance cartograms","text":"Optionally can provide matrix travel times points well positions source points use dc_generate_positions_from_durations function generate image points. function perform Principal Coordinates Analysis (PCoA, form Multidimensional scaling) durations matrix generate positions points 2D space. adjust points (using affine Euclidean transformation) source points generate final image points can used create interpolation grid. cartogram obtained method qualifies global accessibility (multipolar accessibility) territory visualizing travel times pairs locations.","code":"# Read source points and layer to be deformed source_pts <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = 'prefecture', quiet = TRUE ) background_layer <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = 'departement', quiet = TRUE )  # Read durations between points d <- read.csv(system.file(\"csv/mat.csv\", package = \"distanamo\"), row.names = 1) # The CSV is a time matrix structured as follow #           AGEN   BORDEAUX   GRENOBLE etc. # AGEN      0.0    111.2      200.3 # BORDEAUX  112.3  0.0        300.1 # GRENOBLE  199.4  301.1      0.0 # etc.  pos_result <- dc_generate_positions_from_durations(d, source_pts)  # Display useful information about the result of the positioning summary(pos_result) plot(pos_result)  # Create the interpolation grid igrid <- dc_create(   pos_result$source_points,   pos_result$image_points,   2.0,   sf::st_bbox(background_layer) )  summary(igrid) plot(igrid)  # Deform the target layer deformed_background <- dc_interpolate(igrid, background_layer)  plot(sf::st_geometry(deformed_background))"},{"path":"https://riatelab.github.io/distanamo/index.html","id":"deforming-multiple-layers-at-once","dir":"","previous_headings":"Usage","what":"Deforming multiple layers at once","title":"Distanamo: distance cartograms","text":"want deform multiple layers parallel interpolation grid, can use dc_interpolate_parallel function.","code":"result_layers <- dc_interpolate_parallel(   igrid,   list(layer1, layer2, layer3) )"},{"path":"https://riatelab.github.io/distanamo/index.html","id":"examples","dir":"","previous_headings":"","what":"Examples","title":"Distanamo: distance cartograms","text":"Maps made mapsf.","code":""},{"path":"https://riatelab.github.io/distanamo/index.html","id":"more-information-about-the-origin-of-the-method","dir":"","previous_headings":"","what":"More information about the origin of the method","title":"Distanamo: distance cartograms","text":"port Darcy standalone software regarding bidimensional regression background layers deformation. credit contribution method goes Colette Cauvin (Théma - Univ. Franche-Comté) reference Java implementation goes Gilles Vuidel (Théma - Univ. Franche-Comté). method also available QGIS plugin (GitHub repository / QGIS plugin repository). R package wrapper around Rust library distance-cartogram-rs can used directly Rust.","code":""},{"path":[]},{"path":"https://riatelab.github.io/distanamo/index.html","id":"about-the-method","dir":"","previous_headings":"References","what":"About the method","title":"Distanamo: distance cartograms","text":"Cauvin, C. (2005). systemic approach transport accessibility. methodology developed Strasbourg: 1982-2002. Cybergeo: European Journal Geography. DOI: 10.4000/cybergeo.3425. Cauvin, C., & Vuidel, G. (2009). Darcy 2.0 - Mode d’emploi (https://thema.univ-fcomte.fr/productions/software/darcy/download/me_darcy.pdf). Tobler, W. R. (1994). Bidimensional regression. Geographical Analysis, 26(3), 187-212. DOI: 10.1111/j.1538-4632.1994.tb00320.x Bronner, . C. (2023). Cartogrammes, anamorphoses : des territoires transformés. Traitements et cartographie de l’information géographique, ISTE Group (pp.231-271). DOI: 10.51926/ISTE.9161.ch7.","code":""},{"path":"https://riatelab.github.io/distanamo/index.html","id":"about-distance-or-time-cartograms-in-general-their-usability-the-other-methods-to-create-them-etc","dir":"","previous_headings":"References","what":"About distance (or time) cartograms in general: their usability, the other methods to create them, etc.","title":"Distanamo: distance cartograms","text":"Ullah, R., Mengistu, E., van Elzakker, C. & Kraak, M. (2016). Usability evaluation centered time cartograms. Open Geosciences, 8(1), 337-359. DOI: 10.1515/geo-2016-0035. Hong, S., Kim, Y. S., Yoon, J. C., & Aragon, C. (2014). Traffigram: distortion clarification via isochronal cartography. Proceedings SIGCHI Conference Human Factors Computing Systems (pp. 907–916). Association Computing Machinery. DOI: 10.1145/2556288.2557224. Ullah, R., Kraak, M. J., & Van Elzakker, C. (2013). Using cartograms explore temporal data: work. GeoViz, 2013. Ullah, R., & Kraak, M. J. (2014). alternative method constructing time cartograms visual representation scheduled movement data. Journal Maps, 11(4), 674–687. DOI: 10.1080/17445647.2014.935502. Hong, S., Kocielnik, R., Min-Joon Yoo, Battersby, S., Juho Kim, & Aragon, C. (2017). Designing interactive distance cartograms support urban travelers. 2017 IEEE Pacific Visualization Symposium (PacificVis) (pp. 81-90). Shimizu, E. Inoue, R. (2009). new algorithm distance cartogram construction. International Journal Geographical Information Science 23(11): 1453-1470. DOI: 10.1080/13658810802186882.","code":""},{"path":"https://riatelab.github.io/distanamo/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Distanamo: distance cartograms","text":"GPL-3.0","code":""},{"path":"https://riatelab.github.io/distanamo/reference/dc_adjust.html","id":null,"dir":"Reference","previous_headings":"","what":"Adjusts image points to source points — dc_adjust","title":"Adjusts image points to source points — dc_adjust","text":"Computes positions adjusted points fitting image points source points. Note points generated dc_generate_positions_from_durations function dc_move_from_reference_point need adjusted.","code":""},{"path":"https://riatelab.github.io/distanamo/reference/dc_adjust.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adjusts image points to source points — dc_adjust","text":"","code":"dc_adjust(source_points, image_points, adjustment_type = \"euclidean\")"},{"path":"https://riatelab.github.io/distanamo/reference/dc_adjust.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adjusts image points to source points — dc_adjust","text":"source_points source point layer, sf POINT object image_points layer point adjusted fit source_points, sf POINT object adjustment_type adjustment type use, either \"euclidean\" \"affine\"","code":""},{"path":"https://riatelab.github.io/distanamo/reference/dc_adjust.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adjusts image points to source points — dc_adjust","text":"list object transformation matrix, various metrics adjusted points","code":""},{"path":"https://riatelab.github.io/distanamo/reference/dc_adjust.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Adjusts image points to source points — dc_adjust","text":"","code":"library(sf) #> Linking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE  # Read source points source_pts <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"prefecture\", quiet = TRUE )  # Read non adjusted image points image_pts_not_adj <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"image-points-not-adjusted\", quiet = TRUE )  # Read the background layer to deform background_layer <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"departement\", quiet = TRUE )  # Adjust image points to source points adj_result <- dc_adjust(   source_points = source_pts,   image_points = image_pts_not_adj,   \"euclidean\" )  # Use adjusted points to create the interpolation grid igrid <- dc_create(   source_points = source_pts,   image_points = adj_result$image_points,   precision = 2,   bbox = st_bbox(background_layer) )  # Deform the target layer background_deformed <- dc_interpolate(   interpolation_grid = igrid,   layer_to_deform = background_layer )"},{"path":"https://riatelab.github.io/distanamo/reference/dc_combine_bbox.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the bounding box that covers all the layers — dc_combine_bbox","title":"Compute the bounding box that covers all the layers — dc_combine_bbox","text":"Takes list sf objects compute bounding box covers .","code":""},{"path":"https://riatelab.github.io/distanamo/reference/dc_combine_bbox.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the bounding box that covers all the layers — dc_combine_bbox","text":"","code":"dc_combine_bbox(list_layers)"},{"path":"https://riatelab.github.io/distanamo/reference/dc_combine_bbox.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the bounding box that covers all the layers — dc_combine_bbox","text":"list_layers list sf objects","code":""},{"path":"https://riatelab.github.io/distanamo/reference/dc_combine_bbox.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the bounding box that covers all the layers — dc_combine_bbox","text":"sf bounding box returned.","code":""},{"path":"https://riatelab.github.io/distanamo/reference/dc_combine_bbox.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute the bounding box that covers all the layers — dc_combine_bbox","text":"","code":"library(sf)  # Read source points source_pts <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"prefecture\", quiet = TRUE )  # Read the background layer to deform background_layer <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"departement\", quiet = TRUE )  bbox <- dc_combine_bbox(list(source_pts, background_layer)) bbox #>      xmin      ymin      xmax      ymax  #>   99217.1 6137115.5 1082898.1 7110480.1"},{"path":"https://riatelab.github.io/distanamo/reference/dc_concentric_circles.html","id":null,"dir":"Reference","previous_headings":"","what":"Create concentric circles around the reference point — dc_concentric_circles","title":"Create concentric circles around the reference point — dc_concentric_circles","text":"Create concentric circles around reference point, using results dc_move_from_reference_point.","code":""},{"path":"https://riatelab.github.io/distanamo/reference/dc_concentric_circles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create concentric circles around the reference point — dc_concentric_circles","text":"","code":"dc_concentric_circles(   positioning_result,   steps = list(30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330, 360) )"},{"path":"https://riatelab.github.io/distanamo/reference/dc_concentric_circles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create concentric circles around the reference point — dc_concentric_circles","text":"positioning_result object returned dc_move_from_reference_point function. steps steps (unit durations used ine dc_move_from_reference_point function) creating circles.","code":""},{"path":"https://riatelab.github.io/distanamo/reference/dc_concentric_circles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create concentric circles around the reference point — dc_concentric_circles","text":"sf LINESTRING object","code":""},{"path":"https://riatelab.github.io/distanamo/reference/dc_concentric_circles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create concentric circles around the reference point — dc_concentric_circles","text":"","code":"library(sf)  # Read source points source_pts <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"prefecture\", quiet = TRUE )  # Read the background layer to deform background_layer <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"departement\", quiet = TRUE )  durations_mat <- read.csv(system.file(\"csv/mat.csv\", package = \"distanamo\"), row.names = 1) dur <- durations_mat[\"CAEN\", ]  source_pts$durations <- as.double(dur)  ref_point <- subset(source_pts, source_pts$NOM_COM == \"CAEN\") other_points <- subset(source_pts, !source_pts$NOM_COM == \"CAEN\")  # Generate position from durations between the reference point # and the other points positioning_result <- dc_move_from_reference_point(   reference_point = ref_point,   other_points = other_points,   duration_col_name = \"durations\",   factor = 1 )  # Create the interpolation grid igrid <- dc_create(   source_points = positioning_result$source_points,   image_points = positioning_result$image_points,   precision = 2.0,   bbox = st_bbox(background_layer) )  # Use the positioning result to create concentric circles # every 60-minutes circles <- dc_concentric_circles(   positioning_result,   c(60, 120, 180, 240, 300, 360, 420, 480, 540, 600, 660, 720) )  # Deform the background layer background_deformed <- dc_interpolate(   interpolation_grid = igrid,   layer_to_deform = background_layer )"},{"path":"https://riatelab.github.io/distanamo/reference/dc_create.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an interpolation grid — dc_create","title":"Create an interpolation grid — dc_create","text":"Create new interpolation grid covers source points cell size deduced precision. grid interpolated match image points. allows one interpolate point grid (enabling deformation geometries background layers) retrieve useful metrics deformation. bbox provided cover source points, grid extended cover source points. precision controls size grid cells (higher precise, example 0.5 generally gives coarse result, 2 satisfactory result 4 particularly fine result). precision 2 usually good default value. number iterations controls number iterations interpolation. generally 4 times square root number points (default value niter parameter provided. Note number source points must equal number image points, either must supplied order (homologous points), name field containing identifier must supplied enable sorted order.","code":""},{"path":"https://riatelab.github.io/distanamo/reference/dc_create.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an interpolation grid — dc_create","text":"","code":"dc_create(source_points, image_points, precision, bbox, niter, sort_by)"},{"path":"https://riatelab.github.io/distanamo/reference/dc_create.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an interpolation grid — dc_create","text":"source_points source point layer, sf POINT object image_points image point layer, sf POINT object precision precision grid created (higher value means higher precision - 0.5 gives usually coarse result, 2 good default, 4 detailed) bbox bounding box grid created niter number iterations (default floor(4 * sqrt(length(source_points)))) sort_by field sort source image points ","code":""},{"path":"https://riatelab.github.io/distanamo/reference/dc_create.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an interpolation grid — dc_create","text":"interpolation grid used transform layers","code":""},{"path":"https://riatelab.github.io/distanamo/reference/dc_create.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an interpolation grid — dc_create","text":"","code":"library(sf)  # Read source points source_pts <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"prefecture\", quiet = TRUE )  # Read image points image_pts <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"image-points\", quiet = TRUE )  # Read the background layer to deform background_layer <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"departement\", quiet = TRUE )  # Create the interpolation grid igrid <- dc_create(   source_points = source_pts,   image_points = image_pts,   precision = 2,   bbox = st_bbox(background_layer) )  # Plot various depictions of the interpolation grid plot(igrid)      # Useful information about the interpolation grid summary(igrid) #> Summary of the interpolation grid: #> Number of cells: 441  #> Precision: 50462.76 (α = 2)  #> Deformation strength: 1.041534  #> Mean absolute error: 3734.717  #> RMSE (interp - image): 4989.972  #> RMSE x (interp - image): 4060.84  #> RMSE y (interp - image): 2899.896  #> RMSE (interp - source): 42725.87  #> RMSE x (interp - source): 32080.25  #> RMSE y (interp - source): 28219.8  #> R squared: 0.9997285   # Deform the target layer background_deformed <- dc_interpolate(   interpolation_grid = igrid,   layer_to_deform = background_layer )  plot(st_geometry(background_deformed))"},{"path":"https://riatelab.github.io/distanamo/reference/dc_generate_positions_from_durations.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate positions from durations matrix — dc_generate_positions_from_durations","title":"Generate positions from durations matrix — dc_generate_positions_from_durations","text":"Generate positions durations matrix, using PCoA find relative positions points, find best fit source points image points using affine Euclidean transformation.","code":""},{"path":"https://riatelab.github.io/distanamo/reference/dc_generate_positions_from_durations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate positions from durations matrix — dc_generate_positions_from_durations","text":"","code":"dc_generate_positions_from_durations(   durations,   source_points,   adjustment_type = \"euclidean\" )"},{"path":"https://riatelab.github.io/distanamo/reference/dc_generate_positions_from_durations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate positions from durations matrix — dc_generate_positions_from_durations","text":"durations durations matrix source_points source points, sf POINT object adjustment_type adjustment type use, either \"euclidean\" \"affine\"","code":""},{"path":"https://riatelab.github.io/distanamo/reference/dc_generate_positions_from_durations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate positions from durations matrix — dc_generate_positions_from_durations","text":"list object source points image points, ready used dc_create function","code":""},{"path":"https://riatelab.github.io/distanamo/reference/dc_generate_positions_from_durations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate positions from durations matrix — dc_generate_positions_from_durations","text":"","code":"library(sf)  # Read source points source_pts <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"prefecture\", quiet = TRUE )  # Read the background layer to deform background_layer <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"departement\", quiet = TRUE )  # Read durations matrix durations_mat <- read.csv(system.file(\"csv/mat.csv\", package = \"distanamo\"), row.names = 1)  # Generate the positions from the whole duration matrix and # adjust the result to the source points pos_result <- dc_generate_positions_from_durations(   durations = durations_mat,   source_points = source_pts,   adjustment_type = \"euclidean\" )  # Display and plot useful information about the positioning step plot(pos_result)  summary(pos_result) #> Summary of the multipolar displacement result: #> Min displacement: 2349.236 [m]  #> Mean displacement: 34569.15 [m]  #> Max displacement: 108405.5 [m]  #> Transformation matrix: #>      358.1063 1126.673 673162.7  #>      -1170.315 396.8617 6619705  #> Scale: 1208.994  #> RMSE: 39842.59  #> RMSE x: 25310.6  #> RMSE y: 30770.21   # Use the result of the positioning to create the interpolation grid igrid <- dc_create(   source_points = pos_result$source_points,   image_points = pos_result$image_points,   precision = 2.0,   bbox = st_bbox(background_layer) )  # Deform the background layer background_deformed <- dc_interpolate(   interpolation_grid = igrid,   layer_to_deform = background_layer )"},{"path":"https://riatelab.github.io/distanamo/reference/dc_interpolate.html","id":null,"dir":"Reference","previous_headings":"","what":"Interpolate a sf layer using the interpolation grid — dc_interpolate","title":"Interpolate a sf layer using the interpolation grid — dc_interpolate","text":"Interpolate sf layer using interpolation grid.","code":""},{"path":"https://riatelab.github.io/distanamo/reference/dc_interpolate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interpolate a sf layer using the interpolation grid — dc_interpolate","text":"","code":"dc_interpolate(interpolation_grid, layer_to_deform)"},{"path":"https://riatelab.github.io/distanamo/reference/dc_interpolate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interpolate a sf layer using the interpolation grid — dc_interpolate","text":"interpolation_grid interpolation grid layer_to_deform sf layer interpolate","code":""},{"path":"https://riatelab.github.io/distanamo/reference/dc_interpolate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interpolate a sf layer using the interpolation grid — dc_interpolate","text":"sf layer deformed interpolation grid","code":""},{"path":"https://riatelab.github.io/distanamo/reference/dc_interpolate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interpolate a sf layer using the interpolation grid — dc_interpolate","text":"","code":"library(sf)  # Read source points source_pts <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"prefecture\", quiet = TRUE )  # Read image points image_pts <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"image-points\", quiet = TRUE )  # Read the background layer to deform background_layer <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"departement\", quiet = TRUE )  # Create the interpolation grid igrid <- dc_create(   source_points = source_pts,   image_points = image_pts,   precision = 2,   bbox = st_bbox(background_layer) )  # Plot various depictions of the interpolation grid plot(igrid)      # Useful information about the interpolation grid summary(igrid) #> Summary of the interpolation grid: #> Number of cells: 441  #> Precision: 50462.76 (α = 2)  #> Deformation strength: 1.041534  #> Mean absolute error: 3734.717  #> RMSE (interp - image): 4989.972  #> RMSE x (interp - image): 4060.84  #> RMSE y (interp - image): 2899.896  #> RMSE (interp - source): 42725.87  #> RMSE x (interp - source): 32080.25  #> RMSE y (interp - source): 28219.8  #> R squared: 0.9997285   # Deform the target layer background_deformed <- dc_interpolate(   interpolation_grid = igrid,   layer_to_deform = background_layer )  plot(st_geometry(background_deformed))"},{"path":"https://riatelab.github.io/distanamo/reference/dc_interpolate_parallel.html","id":null,"dir":"Reference","previous_headings":"","what":"Deform a list of sf layers using the interpolation grid — dc_interpolate_parallel","title":"Deform a list of sf layers using the interpolation grid — dc_interpolate_parallel","text":"Interpolate list sf layers using interpolation grid.","code":""},{"path":"https://riatelab.github.io/distanamo/reference/dc_interpolate_parallel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deform a list of sf layers using the interpolation grid — dc_interpolate_parallel","text":"","code":"dc_interpolate_parallel(interpolation_grid, layers_to_deform)"},{"path":"https://riatelab.github.io/distanamo/reference/dc_interpolate_parallel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deform a list of sf layers using the interpolation grid — dc_interpolate_parallel","text":"interpolation_grid interpolation grid layers_to_deform list sf layers interpolate","code":""},{"path":"https://riatelab.github.io/distanamo/reference/dc_interpolate_parallel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deform a list of sf layers using the interpolation grid — dc_interpolate_parallel","text":"sf layers deformed interpolation grid","code":""},{"path":"https://riatelab.github.io/distanamo/reference/dc_interpolate_parallel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Deform a list of sf layers using the interpolation grid — dc_interpolate_parallel","text":"","code":"library(sf)  # Read source points source_pts <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"prefecture\", quiet = TRUE )  # Read non adjusted image points image_pts_not_adj <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"image-points-not-adjusted\", quiet = TRUE )  # Read the background layer to deform background_layer <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"departement\", quiet = TRUE )  # Adjust image points to source points adj_result <- dc_adjust(   source_points = source_pts,   image_points = image_pts_not_adj,   \"euclidean\" )  # Use adjusted points to create the interpolation grid igrid <- dc_create(   source_points = source_pts,   image_points = adj_result$image_points,   precision = 2,   bbox = st_bbox(background_layer) )  # Deform the target layer background_deformed <- dc_interpolate_parallel(   interpolation_grid = igrid,   layers_to_deform = list(background_layer = background_layer, source_pts = source_pts) )"},{"path":"https://riatelab.github.io/distanamo/reference/dc_move_from_reference_point.html","id":null,"dir":"Reference","previous_headings":"","what":"Move points from a reference point — dc_move_from_reference_point","title":"Move points from a reference point — dc_move_from_reference_point","text":"Move points reference point using durations reference point points.","code":""},{"path":"https://riatelab.github.io/distanamo/reference/dc_move_from_reference_point.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Move points from a reference point — dc_move_from_reference_point","text":"","code":"dc_move_from_reference_point(   reference_point,   other_points,   duration_col_name,   factor )"},{"path":"https://riatelab.github.io/distanamo/reference/dc_move_from_reference_point.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Move points from a reference point — dc_move_from_reference_point","text":"reference_point point points moved, sf POINT object other_points points move, sf POINT object duration_col_name name column containing durations other_points sf object factor factor displacement (default: 1)","code":""},{"path":"https://riatelab.github.io/distanamo/reference/dc_move_from_reference_point.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Move points from a reference point — dc_move_from_reference_point","text":"list object source points image points, ready used dc_create function","code":""},{"path":"https://riatelab.github.io/distanamo/reference/dc_move_from_reference_point.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Move points from a reference point — dc_move_from_reference_point","text":"","code":"library(sf)  # Read source points source_pts <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"prefecture\", quiet = TRUE )  # Read the background layer to deform background_layer <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"departement\", quiet = TRUE )  durations_mat <- read.csv(system.file(\"csv/mat.csv\", package = \"distanamo\"), row.names = 1) dur <- durations_mat[\"CAEN\", ]  source_pts$durations <- as.double(dur)  ref_point <- subset(source_pts, source_pts$NOM_COM == \"CAEN\") other_points <- subset(source_pts, !source_pts$NOM_COM == \"CAEN\")  # Generate position from durations between the reference point # and the other points positioning_result <- dc_move_from_reference_point(   reference_point = ref_point,   other_points = other_points,   duration_col_name = \"durations\",   factor = 1 )  # Display and plot useful information about the positioning step plot(positioning_result)  summary(positioning_result) #> Summary of the unipolar displacement result: #> Min displacement: 821.2748 [m]  #> Mean displacement: 17560.79 [m]  #> Max displacement: 58014.19 [m]   # Create the interpolation grid igrid <- dc_create(   source_points = positioning_result$source_points,   image_points = positioning_result$image_points,   precision = 2.0,   bbox = st_bbox(background_layer) )  # Deform the background layer background_deformed <- dc_interpolate(   interpolation_grid = igrid,   layer_to_deform = background_layer )"},{"path":"https://riatelab.github.io/distanamo/reference/distanamo.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Distance Cartograms — distanamo","title":"Create Distance Cartograms — distanamo","text":"package enables creation often defined distance cartogram. Distance cartograms type cartogram deforms layers map according distances set source points set image points. done extending (interpolation) layer(s) study area (territorial divisions, network...) local displacement source coordinates image coordinates, derived distances pair homologous points (source / image points).","code":""},{"path":[]},{"path":"https://riatelab.github.io/distanamo/reference/distanamo.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create Distance Cartograms — distanamo","text":"Maintainer: Matthieu Viry matthieu.viry@cnrs.fr (ORCID) contributors: Timothée Giraud timothee.giraud@cnrs.fr (ORCID) [contributor]","code":""},{"path":"https://riatelab.github.io/distanamo/reference/plot.adjustment_result.html","id":null,"dir":"Reference","previous_headings":"","what":"plot adjustment_result object — plot.adjustment_result","title":"plot adjustment_result object — plot.adjustment_result","text":"Plot result dc_adjust","code":""},{"path":"https://riatelab.github.io/distanamo/reference/plot.adjustment_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plot adjustment_result object — plot.adjustment_result","text":"","code":"# S3 method for class 'adjustment_result' plot(x, ...)"},{"path":"https://riatelab.github.io/distanamo/reference/plot.adjustment_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plot adjustment_result object — plot.adjustment_result","text":"x object class adjustment_result ... specifications, see plot details","code":""},{"path":"https://riatelab.github.io/distanamo/reference/plot.adjustment_result.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"plot adjustment_result object — plot.adjustment_result","text":"","code":"library(sf)  # Read source points source_pts <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"prefecture\", quiet = TRUE )  # Read non adjusted image points image_pts_not_adj <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"image-points-not-adjusted\", quiet = TRUE )  # Read the background layer to deform background_layer <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"departement\", quiet = TRUE )  # Adjust image points to source points adj_result <- dc_adjust(   source_points = source_pts,   image_points = image_pts_not_adj,   \"euclidean\" )  # Plot result of the adjustment step plot(adj_result)   # Summary statistics of the adjustment step summary(adj_result) #> Summary of the adjustment: #> Min displacement: 2349.236 [m]  #> Mean displacement: 34569.15 [m]  #> Max displacement: 108405.5 [m]  #> Transformation matrix: #>      358.1063 1126.673 673162.7  #>      -1170.315 396.8617 6619705  #> Scale: 1208.994  #> RMSE: 39842.59  #> RMSE x: 25310.6  #> RMSE y: 30770.21"},{"path":"https://riatelab.github.io/distanamo/reference/plot.interpolation_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"plot interpolation_grid object — plot.interpolation_grid","title":"plot interpolation_grid object — plot.interpolation_grid","text":"Plot interpolation grid, resulting dc_create","code":""},{"path":"https://riatelab.github.io/distanamo/reference/plot.interpolation_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plot interpolation_grid object — plot.interpolation_grid","text":"","code":"# S3 method for class 'interpolation_grid' plot(   x,   which = 1:4,   ask = interactive(),   caption = list(\"Source grid\", \"Interpolated grid\", \"Image to interpolated points\",     \"Deformation strength\"),   ... )"},{"path":"https://riatelab.github.io/distanamo/reference/plot.interpolation_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plot interpolation_grid object — plot.interpolation_grid","text":"x object class interpolation_grid plot display, subset 1:4 (default) ask logical; TRUE, user asked plot caption captions appear plots; character vector list valid graphics annotations ... specifications, see plot details","code":""},{"path":"https://riatelab.github.io/distanamo/reference/plot.interpolation_grid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"plot interpolation_grid object — plot.interpolation_grid","text":"","code":"library(sf)  # Read source points source_pts <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"prefecture\", quiet = TRUE )  # Read image points image_pts <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"image-points\", quiet = TRUE )  # Read the background layer to deform background_layer <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"departement\", quiet = TRUE )  # Create the interpolation grid igrid <- dc_create(   source_points = source_pts,   image_points = image_pts,   precision = 2,   bbox = st_bbox(background_layer) )  # Plot various depictions of the interpolation grid plot(igrid)      # Useful information about the interpolation grid summary(igrid) #> Summary of the interpolation grid: #> Number of cells: 441  #> Precision: 50462.76 (α = 2)  #> Deformation strength: 1.041534  #> Mean absolute error: 3734.717  #> RMSE (interp - image): 4989.972  #> RMSE x (interp - image): 4060.84  #> RMSE y (interp - image): 2899.896  #> RMSE (interp - source): 42725.87  #> RMSE x (interp - source): 32080.25  #> RMSE y (interp - source): 28219.8  #> R squared: 0.9997285"},{"path":"https://riatelab.github.io/distanamo/reference/plot.multipolar_displacement_result.html","id":null,"dir":"Reference","previous_headings":"","what":"plot multipolar_displacement_result object — plot.multipolar_displacement_result","title":"plot multipolar_displacement_result object — plot.multipolar_displacement_result","text":"Plot result dc_generate_positions_from_durations","code":""},{"path":"https://riatelab.github.io/distanamo/reference/plot.multipolar_displacement_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plot multipolar_displacement_result object — plot.multipolar_displacement_result","text":"","code":"# S3 method for class 'multipolar_displacement_result' plot(x, ...)"},{"path":"https://riatelab.github.io/distanamo/reference/plot.multipolar_displacement_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plot multipolar_displacement_result object — plot.multipolar_displacement_result","text":"x object class multipolar_displacement_result ... specifications, see plot details","code":""},{"path":"https://riatelab.github.io/distanamo/reference/plot.multipolar_displacement_result.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"plot multipolar_displacement_result object — plot.multipolar_displacement_result","text":"","code":"library(sf)  # Read source points source_pts <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"prefecture\", quiet = TRUE )  # Read the background layer to deform background_layer <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"departement\", quiet = TRUE )  # Read durations matrix durations_mat <- read.csv(system.file(\"csv/mat.csv\", package = \"distanamo\"), row.names = 1)  # Generate the positions from the whole duration matrix and # adjust the result to the source points pos_result <- dc_generate_positions_from_durations(   durations = durations_mat,   source_points = source_pts,   adjustment_type = \"euclidean\" )  # Plot result of the positioning step plot(pos_result)   # Summary statistics of the positioning step summary(pos_result) #> Summary of the multipolar displacement result: #> Min displacement: 2349.236 [m]  #> Mean displacement: 34569.15 [m]  #> Max displacement: 108405.5 [m]  #> Transformation matrix: #>      358.1063 1126.673 673162.7  #>      -1170.315 396.8617 6619705  #> Scale: 1208.994  #> RMSE: 39842.59  #> RMSE x: 25310.6  #> RMSE y: 30770.21"},{"path":"https://riatelab.github.io/distanamo/reference/plot.unipolar_displacement_result.html","id":null,"dir":"Reference","previous_headings":"","what":"plot unipolar_displacement_result object — plot.unipolar_displacement_result","title":"plot unipolar_displacement_result object — plot.unipolar_displacement_result","text":"Plot result dc_move_from_reference_point","code":""},{"path":"https://riatelab.github.io/distanamo/reference/plot.unipolar_displacement_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plot unipolar_displacement_result object — plot.unipolar_displacement_result","text":"","code":"# S3 method for class 'unipolar_displacement_result' plot(x, ...)"},{"path":"https://riatelab.github.io/distanamo/reference/plot.unipolar_displacement_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plot unipolar_displacement_result object — plot.unipolar_displacement_result","text":"x object class unipolar_displacement_result ... specifications, see plot details","code":""},{"path":"https://riatelab.github.io/distanamo/reference/plot.unipolar_displacement_result.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"plot unipolar_displacement_result object — plot.unipolar_displacement_result","text":"","code":"library(sf)  # Read source points source_pts <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"prefecture\", quiet = TRUE )  # Read the background layer to deform background_layer <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"departement\", quiet = TRUE )  durations_mat <- read.csv(system.file(\"csv/mat.csv\", package = \"distanamo\"), row.names = 1) dur <- durations_mat[\"CAEN\", ]  source_pts$durations <- as.double(dur)  ref_point <- subset(source_pts, source_pts$NOM_COM == \"CAEN\") other_points <- subset(source_pts, !source_pts$NOM_COM == \"CAEN\")  # Generate position from durations between the reference point # and the other points positioning_result <- dc_move_from_reference_point(   reference_point = ref_point,   other_points = other_points,   duration_col_name = \"durations\",   factor = 1 )  # Plot result of the positioning step plot(positioning_result)   # Summary statistics of the positioning step summary(positioning_result) #> Summary of the unipolar displacement result: #> Min displacement: 821.2748 [m]  #> Mean displacement: 17560.79 [m]  #> Max displacement: 58014.19 [m]"},{"path":"https://riatelab.github.io/distanamo/reference/summary.adjustment_result.html","id":null,"dir":"Reference","previous_headings":"","what":"summary adjustment_result object — summary.adjustment_result","title":"summary adjustment_result object — summary.adjustment_result","text":"Compute summary statistics adjustment_result","code":""},{"path":"https://riatelab.github.io/distanamo/reference/summary.adjustment_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"summary adjustment_result object — summary.adjustment_result","text":"","code":"# S3 method for class 'adjustment_result' summary(object, ...)"},{"path":"https://riatelab.github.io/distanamo/reference/summary.adjustment_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"summary adjustment_result object — summary.adjustment_result","text":"object object class adjustment_result ... specifications, see summary details","code":""},{"path":"https://riatelab.github.io/distanamo/reference/summary.adjustment_result.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"summary adjustment_result object — summary.adjustment_result","text":"","code":"library(sf)  # Read source points source_pts <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"prefecture\", quiet = TRUE )  # Read non adjusted image points image_pts_not_adj <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"image-points-not-adjusted\", quiet = TRUE )  # Read the background layer to deform background_layer <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"departement\", quiet = TRUE )  # Adjust image points to source points adj_result <- dc_adjust(   source_points = source_pts,   image_points = image_pts_not_adj,   \"euclidean\" )  # Plot result of the adjustment step plot(adj_result)   # Summary statistics of the adjustment step summary(adj_result) #> Summary of the adjustment: #> Min displacement: 2349.236 [m]  #> Mean displacement: 34569.15 [m]  #> Max displacement: 108405.5 [m]  #> Transformation matrix: #>      358.1063 1126.673 673162.7  #>      -1170.315 396.8617 6619705  #> Scale: 1208.994  #> RMSE: 39842.59  #> RMSE x: 25310.6  #> RMSE y: 30770.21"},{"path":"https://riatelab.github.io/distanamo/reference/summary.interpolation_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"summary interpolation_grid object — summary.interpolation_grid","title":"summary interpolation_grid object — summary.interpolation_grid","text":"Compute summary statistics interpolation_grid","code":""},{"path":"https://riatelab.github.io/distanamo/reference/summary.interpolation_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"summary interpolation_grid object — summary.interpolation_grid","text":"","code":"# S3 method for class 'interpolation_grid' summary(object, ...)"},{"path":"https://riatelab.github.io/distanamo/reference/summary.interpolation_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"summary interpolation_grid object — summary.interpolation_grid","text":"object object class interpolation_grid ... specifications, see summary details","code":""},{"path":"https://riatelab.github.io/distanamo/reference/summary.interpolation_grid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"summary interpolation_grid object — summary.interpolation_grid","text":"","code":"library(sf)  # Read source points source_pts <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"prefecture\", quiet = TRUE )  # Read image points image_pts <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"image-points\", quiet = TRUE )  # Read the background layer to deform background_layer <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"departement\", quiet = TRUE )  # Create the interpolation grid igrid <- dc_create(   source_points = source_pts,   image_points = image_pts,   precision = 2,   bbox = st_bbox(background_layer) )  # Plot various depictions of the interpolation grid plot(igrid)      # Useful information about the interpolation grid summary(igrid) #> Summary of the interpolation grid: #> Number of cells: 441  #> Precision: 50462.76 (α = 2)  #> Deformation strength: 1.041534  #> Mean absolute error: 3734.717  #> RMSE (interp - image): 4989.972  #> RMSE x (interp - image): 4060.84  #> RMSE y (interp - image): 2899.896  #> RMSE (interp - source): 42725.87  #> RMSE x (interp - source): 32080.25  #> RMSE y (interp - source): 28219.8  #> R squared: 0.9997285"},{"path":"https://riatelab.github.io/distanamo/reference/summary.multipolar_displacement_result.html","id":null,"dir":"Reference","previous_headings":"","what":"summary multipolar_displacement_result object — summary.multipolar_displacement_result","title":"summary multipolar_displacement_result object — summary.multipolar_displacement_result","text":"Compute summary statistics multipolar_displacement_result","code":""},{"path":"https://riatelab.github.io/distanamo/reference/summary.multipolar_displacement_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"summary multipolar_displacement_result object — summary.multipolar_displacement_result","text":"","code":"# S3 method for class 'multipolar_displacement_result' summary(object, ...)"},{"path":"https://riatelab.github.io/distanamo/reference/summary.multipolar_displacement_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"summary multipolar_displacement_result object — summary.multipolar_displacement_result","text":"object object class multipolar_displacement_result ... specifications, see summary details","code":""},{"path":"https://riatelab.github.io/distanamo/reference/summary.multipolar_displacement_result.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"summary multipolar_displacement_result object — summary.multipolar_displacement_result","text":"","code":"library(sf)  # Read source points source_pts <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"prefecture\", quiet = TRUE )  # Read the background layer to deform background_layer <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"departement\", quiet = TRUE )  # Read durations matrix durations_mat <- read.csv(system.file(\"csv/mat.csv\", package = \"distanamo\"), row.names = 1)  # Generate the positions from the whole duration matrix and # adjust the result to the source points pos_result <- dc_generate_positions_from_durations(   durations = durations_mat,   source_points = source_pts,   adjustment_type = \"euclidean\" )  # Plot result of the positioning step plot(pos_result)   # Summary statistics of the positioning step summary(pos_result) #> Summary of the multipolar displacement result: #> Min displacement: 2349.236 [m]  #> Mean displacement: 34569.15 [m]  #> Max displacement: 108405.5 [m]  #> Transformation matrix: #>      358.1063 1126.673 673162.7  #>      -1170.315 396.8617 6619705  #> Scale: 1208.994  #> RMSE: 39842.59  #> RMSE x: 25310.6  #> RMSE y: 30770.21"},{"path":"https://riatelab.github.io/distanamo/reference/summary.unipolar_displacement_result.html","id":null,"dir":"Reference","previous_headings":"","what":"summary unipolar_displacement_result object — summary.unipolar_displacement_result","title":"summary unipolar_displacement_result object — summary.unipolar_displacement_result","text":"Compute summary statistics unipolar_displacement_result","code":""},{"path":"https://riatelab.github.io/distanamo/reference/summary.unipolar_displacement_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"summary unipolar_displacement_result object — summary.unipolar_displacement_result","text":"","code":"# S3 method for class 'unipolar_displacement_result' summary(object, ...)"},{"path":"https://riatelab.github.io/distanamo/reference/summary.unipolar_displacement_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"summary unipolar_displacement_result object — summary.unipolar_displacement_result","text":"object object class unipolar_displacement_result ... specifications, see summary details","code":""},{"path":"https://riatelab.github.io/distanamo/reference/summary.unipolar_displacement_result.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"summary unipolar_displacement_result object — summary.unipolar_displacement_result","text":"","code":"library(sf)  # Read source points source_pts <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"prefecture\", quiet = TRUE )  # Read the background layer to deform background_layer <- st_read(   dsn = system.file(\"gpkg/data-prefecture.gpkg\", package = \"distanamo\"),   layer = \"departement\", quiet = TRUE )  durations_mat <- read.csv(system.file(\"csv/mat.csv\", package = \"distanamo\"), row.names = 1) dur <- durations_mat[\"CAEN\", ]  source_pts$durations <- as.double(dur)  ref_point <- subset(source_pts, source_pts$NOM_COM == \"CAEN\") other_points <- subset(source_pts, !source_pts$NOM_COM == \"CAEN\")  # Generate position from durations between the reference point # and the other points positioning_result <- dc_move_from_reference_point(   reference_point = ref_point,   other_points = other_points,   duration_col_name = \"durations\",   factor = 1 )  # Plot result of the positioning step plot(positioning_result)   # Summary statistics of the positioning step summary(positioning_result) #> Summary of the unipolar displacement result: #> Min displacement: 821.2748 [m]  #> Mean displacement: 17560.79 [m]  #> Max displacement: 58014.19 [m]"},{"path":"https://riatelab.github.io/distanamo/news/index.html","id":"distanamo-020","dir":"Changelog","previous_headings":"","what":"distanamo 0.2.0","title":"distanamo 0.2.0","text":"Improve documentation functions. Add static site containing vignettes.","code":""},{"path":"https://riatelab.github.io/distanamo/news/index.html","id":"distanamo-010","dir":"Changelog","previous_headings":"","what":"distanamo 0.1.0","title":"distanamo 0.1.0","text":"Initial release.","code":""}]
